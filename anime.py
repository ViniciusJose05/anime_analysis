# -*- coding: utf-8 -*-
"""anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwJb1_8QjbIvOSElGqKC8x-H_iecRHnA

# Análise de Dados em Séries de Anime:  Gêneros, Avaliações e Tendências

### Equipe:
* Maria Júlia Silva Fonseca Guedes Nobre
* Vinícius José Aragão de Almeida Barrozo

### Objetivos:
- Identificar os gêneros mais frequentes.
- Avaliar quais gêneros têm as melhores (e piores) notas médias.
- Descobrir as combinações de gêneros mais comuns.
- Analisar a relação entre popularidade e avaliação.
- Testar um modelo preditivo baseado nas avaliações.

# 1. Inicialização da Database

Download dos arquivos via API do kaggle e criação do dataframe inicial
"""

import polars as pl
import numpy as np
from sklearn.model_selection import KFold
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
from numpy import mean
import os

"""# 4. Modelo SVM para predição de notas

### 4.1. Filtragem das colunas necessárias
"""


def carregar_dados_anime():
    # download do arquivo anime.csv via API do kaggle caso ele não esteja presente
    if not os.path.exists("databases/anime.csv"):
        os.makedirs("databases", exist_ok=True)
        import kaggle
        kaggle.api.dataset_download_files('hernan4444/anime-recommendation-database-2020', path='databases', unzip=True)
    # leitura do arquivo anime.csv e filtragem das colunas necessárias
    df = pl.read_csv("databases/anime.csv", null_values="Unknown")
    df = df.filter(pl.col('Score').is_not_null() & pl.col('Genres').is_not_null())
    df = df.with_columns([
        pl.col('Genres').str.split(', ').alias('Genres')
    ])
    df = df.with_columns([
        pl.col('Genres').list.eval(
            pl.when(pl.element() == pl.lit("Hentai")).then(pl.lit("Adult Content")).otherwise(pl.element())
        ).alias("Genres")
    ])
    df = df.with_columns(
        pl.col("Genres").map_elements(lambda genres: ", ".join(sorted(genres)), return_dtype=pl.String).alias("Genres_combination")
    )
    return df


df_clean = carregar_dados_anime()

df_para_ml = df_clean.select(
    ['MAL_ID', 'Name', 'Genres', 'Score']
)

"""### 4.2. One-Hot Encoding nos generos das listas de cada linha

Uso de Machine Learning utilizando a database a fim de validar as transformações realizadas e uso da mesma
"""


def one_hot_encode(df, column_name):
    # Get all unique genres
    all_genres = df[column_name].explode().unique().sort()

    expressions = []
    for genre in all_genres:
        expressions.append(
            pl.col(column_name).list.contains(genre).alias(f"{column_name}_{genre}")
        )

    df = df.with_columns(expressions)
    return df.drop(column_name)


df_para_ml = one_hot_encode(df_para_ml, 'Genres')
df_para_encontrar = df_para_ml.drop('Name')
df_para_ml = df_para_ml.drop('Name', 'MAL_ID')


"""### 4.3. Função de treinamento e teste

Implementação de modelo de KNN utilizando 10-10-fold para predição da nota baseado em generos, contendo ou não o numero de membros de cada entrada.
"""


def train_and_evaluate_knn(df, n_neighbors=5):
        X = df.drop('Score').to_numpy()
        y = df['Score'].to_numpy()
        n_folds = 10
        kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)
        mse_scores_temp = []
        last_model = None

        for train_index, test_index in kf.split(X):
            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]
            model = KNeighborsRegressor(n_neighbors=n_neighbors)
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse = mean_squared_error(y_test, y_pred)
            mse_scores_temp.append(mse)
            last_model = model  # Salva o último modelo treinado

        average_mse_temp = mean(mse_scores_temp)
        return average_mse_temp, mse_scores_temp, last_model


_, _, modelo = train_and_evaluate_knn(df_para_ml)

def predict_score_knn(generos_booleans, model=modelo, df_treino=df_para_ml):
        """
        model: modelo KNeighborsRegressor já treinado
        generos_booleans: list[bool], presença dos gêneros na ordem de generos_lista
        df_treino: DataFrame usado no treino (para pegar nomes das colunas)
        """
        # Monta o vetor de entrada (gêneros + membros)
        X_input = np.array([*generos_booleans]).reshape(1, -1)
        # Identifica colunas True
        colunas_true = [col for col, val in zip(df_treino.drop('Score').columns, generos_booleans) if val]
        print("Colunas com valor True:", colunas_true)
        # Faz a predição
        predicted_score = model.predict(X_input)[0]
        return predicted_score

# =====================
# Funções utilitárias para recomendação de animes
# =====================

def get_top_animes_by_genres(generos_booleans, n=10, df_treino=df_para_encontrar):
    """
    Retorna os "n" animes com maior Score que possuem todos os gêneros marcados como True em generos_booleans.
    Prioriza combinações exatas, depois inclui os que têm gêneros extras.
    """
    generos_cols = df_treino.drop('Score','MAL_ID').columns
    generos_array = np.array(df_treino[generos_cols]) == True
    generos_booleans = np.array(generos_booleans, dtype=bool)

    # Máscara para combinação exata
    mask_exata = np.all(generos_array == generos_booleans, axis=1)
    # Máscara para conter todos os gêneros selecionados (mas pode ter extras)
    mask_contem = np.all(generos_array[:, generos_booleans] == True, axis=1)

    # Filtra e ordena
    df_exato = df_treino.filter(mask_exata).sort('Score', descending=True)
    df_extra = df_treino.filter(mask_contem & ~mask_exata).sort('Score', descending=True)

    # Junta e retorna apenas os MAL_IDs
    top_animes = pl.concat([df_exato, df_extra]).head(n)
    return top_animes.select(['MAL_ID'])


# função que baseado numa lista de generos, retorna 5 animes com a maior nota que possuam estes generos
def get_top_animes(generos_booleans, n=10):
    """
    generos_booleans: list[bool], presença dos gêneros na ordem de generos_lista
    "n": número de animes a serem retornados
    Retorna: DataFrame polars com coluna 'MAL_ID' dos animes selecionados
    """
    return get_top_animes_by_genres(generos_booleans, n=n)

# Função para obter informações detalhadas dos animes a partir de um DataFrame polars de MAL_IDs
def get_anime_info(mal_id_df, df_treino=df_clean):
    """
    mal_id_df: DataFrame polars com coluna 'MAL_ID' (resultado de get_top_animes)
    df_treino: DataFrame polars com informações completas dos animes
    Retorna: DataFrame polars com colunas ['Name', 'Score', 'Genres_combination']
    """
    if mal_id_df.is_empty():
        return pl.DataFrame({'Name': [], 'Score': [], 'Genres_combination': []})
    mal_ids = mal_id_df['MAL_ID'].to_list()
    df_filtrado = df_treino.filter(pl.col('MAL_ID').is_in(mal_ids))
    df_info = df_filtrado.select(['Name', 'Score', 'Genres_combination'])
    return df_info

if __name__ == "__main__":
    """### 4.4. Resultados do modelo
    
    4.4.1. Modelo somente com Score e generos
    """

    average_mse, mse_scores, _ = train_and_evaluate_knn(df_para_ml)
    print("MSE por fold:", mse_scores)
    print("Média do erro quadrático médio:", average_mse)