# -*- coding: utf-8 -*-
"""anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwJb1_8QjbIvOSElGqKC8x-H_iecRHnA

# An√°lise de Dados em S√©ries de Anime:  G√™neros, Avalia√ß√µes e Tend√™ncias

### Equipe:
* Maria J√∫lia Silva Fonseca Guedes Nobre
* Vin√≠cius Jos√© Arag√£o de Almeida Barrozo

### Objetivos:
- Identificar os g√™neros mais frequentes.
- Avaliar quais g√™neros t√™m as melhores (e piores) notas m√©dias.
- Descobrir as combina√ß√µes de g√™neros mais comuns.
- Analisar a rela√ß√£o entre popularidade e avalia√ß√£o.
- Testar um modelo preditivo baseado nas avalia√ß√µes.

# 1. Inicializa√ß√£o da Database

Download dos arquivos via API do kaggle e cria√ß√£o do dataframe inicial
"""

import polars as pl

# Baixar e carregar o dataset
anime_polars = pl.read_csv("databases/anime.csv", null_values="Unknown")


"""# 2. Pr√© Processamento

###  2.1. Remover valores nulos em colunas importantes (`Genres` e `Scores`)
"""

df_clean = anime_polars.filter(
    (anime_polars['Genres'].is_not_null()) & (anime_polars['Score'].is_not_null())
)

"""### 2.2. Separar a coluna `Genres` em uma lista"""

df_clean = df_clean.with_columns(
    pl.col('Genres')
    .str.replace("Hentai", "Adult Content")
    .str.split(", ")  # converte para lista
)

"""###  2.3. Criar coluna com combina√ß√£o ordenada dos g√™neros"""


def process_genres(genres):
    try:
        if genres is not None and len(genres) > 0:
            return ", ".join(sorted(genres))
        else:
            return ""
    except (TypeError, AttributeError):
        return ""


df_clean = df_clean.with_columns(
    pl.col('Genres').map_elements(process_genres, return_dtype=pl.Utf8).alias('Genres_combination')
)
# download em formato json da database polars
df_clean.write_json('df_clean.json')

"""# 3. An√°lises Explorat√≥rias"""

import plotly.express as px

# Explodir para an√°lise individual de g√™neros
df_exploded = df_clean.explode('Genres')

"""### 3.1. G√™neros mais frequentes

"""

genero_freq = (
    df_exploded.group_by('Genres')
    .len()
    .sort('len', descending=True)
    .rename({'len': 'Frequencia'})
)

px.bar(genero_freq.to_pandas(), x='Genres', y='Frequencia', title='G√™neros Mais Frequentes')

"""### 3.2. Nota m√©dia por g√™nero"""

genero_score = (
    df_exploded.group_by('Genres')
    .agg(pl.col('Score').mean().alias('Nota M√©dia'))
    .sort('Nota M√©dia', descending=True)
)

px.bar(genero_score.head(15).to_pandas(), x='Genres', y='Nota M√©dia', title='Top 15 G√™neros com Melhores Notas')
px.bar(genero_score.tail(15).to_pandas(), x='Genres', y='Nota M√©dia', title='15 G√™neros com Piores Notas')

"""### 3.3. Combina√ß√µes de g√™neros mais comuns"""

df_combos = df_clean.filter(pl.col('Genres').list.len() > 1)

combo_freq = (
    df_combos
    .group_by('Genres_combination')
    .agg(pl.count().alias('Frequencia'))
    .sort('Frequencia', descending=True)
)

px.bar(combo_freq.head(15).to_pandas(), x='Genres_combination', y='Frequencia',
       title='üîó Combina√ß√µes de G√™neros Mais Comuns (com 2 ou mais g√™neros)')

"""### 3.4. Est√∫dios com melhor nota m√©dia

"""

df_studios = df_clean.filter(
    (pl.col('Studios').is_not_null()) & (pl.col('Studios') != "None")
)

# Agrupar por est√∫dio e calcular m√©dia e contagem
studio_avg = (
    df_studios
    .group_by('Studios')
    .agg([
        pl.col('Score').mean().alias('Nota M√©dia'),
        pl.count().alias('Quantidade de Animes')
    ])
    .filter(pl.col('Quantidade de Animes') >= 5)
    .sort('Nota M√©dia', descending=True)
)

fig = px.bar(
    studio_avg.head(15).to_pandas(),  # Top 15 est√∫dios com melhor nota m√©dia
    x='Studios',
    y='Nota M√©dia',
    title='üé¨ Est√∫dios com as Melhores Notas M√©dias (com pelo menos 5 animes)',
    text='Nota M√©dia',
    labels={'Studios': 'Est√∫dio', 'Nota M√©dia': 'Nota M√©dia'}
)
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(xaxis_tickangle=-45)

""" ### 3.5. Rela√ß√£o entre popularidade e avalia√ß√£o"""

relacao_popularidade = df_clean.select(['Score', 'Members', 'Genres_combination']).to_pandas()

px.scatter(relacao_popularidade, x='Score', y='Members', color='Genres_combination',
           size='Members', hover_data=['Genres_combination'],
           title='Rela√ß√£o entre Nota e Popularidade por G√™nero')

"""# 4. Modelo SVM para predi√ß√£o de notas

### 4.1. Filtragem das colunas necess√°rias
"""

df_para_ml = df_clean.select(
    ['MAL_ID', 'Name', 'Genres', 'Score']
)

df_para_ml_com_membros = df_clean.select(
    ['MAL_ID', 'Name', 'Genres', 'Score', 'Members']
)

"""### 4.2. One-Hot Encoding nos generos das listas de cada linha

Uso de Machine Learning utilizando a database a fim de validar as transforma√ß√µes realizadas e uso da mesma
"""


def one_hot_encode(df, column_name):
    # Get all unique genres
    all_genres = df[column_name].explode().unique().sort()

    expressions = []
    for genre in all_genres:
        expressions.append(
            pl.col(column_name).list.contains(genre).alias(f"{column_name}_{genre}")
        )

    df = df.with_columns(expressions)
    return df.drop(column_name)


df_para_ml = one_hot_encode(df_para_ml, 'Genres')
df_para_ml = df_para_ml.drop('Name', 'MAL_ID')

df_para_ml_com_membros = one_hot_encode(df_para_ml_com_membros, 'Genres')
df_para_ml_com_membros = df_para_ml_com_membros.drop('Name', 'MAL_ID')


"""### 4.3. Fun√ß√£o de treinamento e teste

Implementa√ß√£o de modelo de KNN utilizando 10-10-fold para predi√ß√£o da nota baseado em generos, contendo ou n√£o o numero de membros de cada entrada.
"""

from sklearn.model_selection import KFold
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
import numpy as np


def train_and_evaluate_knn(df, n_neighbors=5):
        X = df.drop('Score').to_numpy()
        y = df['Score'].to_numpy()
        n_folds = 10
        kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)
        mse_scores = []
        last_model = None

        for train_index, test_index in kf.split(X):
            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]
            model = KNeighborsRegressor(n_neighbors=n_neighbors)
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse = mean_squared_error(y_test, y_pred)
            mse_scores.append(mse)
            last_model = model  # Salva o √∫ltimo modelo treinado

        average_mse = np.mean(mse_scores)
        return average_mse, mse_scores, last_model



_, _, modelo = train_and_evaluate_knn(df_para_ml_com_membros)

def predict_score_knn(num_membros, generos_booleans, model = modelo):
    """
    model: modelo KNeighborsRegressor j√° treinado
    num_membros: int, n√∫mero de membros
    generos_booleans: list[bool], presen√ßa dos g√™neros na ordem de generos_lista
    """
    # Monta o vetor de entrada (g√™neros + membros)
    X_input = np.array([*generos_booleans, num_membros]).reshape(1, -1)
    # Faz a predi√ß√£o
    predicted_score = model.predict(X_input)[0]
    return predicted_score

if __name__ == "__main__":
    """### 4.4. Resultados do modelo
    
    4.4.1. Modelo somente com Score e generos
    """

    average_mse, mse_scores, _ = train_and_evaluate_knn(df_para_ml)
    print("MSE por fold:", mse_scores)
    print("M√©dia do erro quadr√°tico m√©dio:", average_mse)

    """4.4.2. Modelo com n√∫mero de membros"""

    average_mse_membros, mse_scores_membros, _ = train_and_evaluate_knn(df_para_ml_com_membros)
    print(f"MSE por fold: {mse_scores_membros}")
    print(f"M√©dia do erro quadr√°tico m√©dio: {average_mse_membros}")

def gerar_graficos_dashboard():
    graficos = {}

    fig1 = px.bar(genero_freq.to_pandas(), x='Genres', y='Frequencia', title='G√™neros Mais Frequentes')
    graficos['grafico_generos_freq'] = fig1.to_html(full_html=False, include_plotlyjs='cdn')

    fig2 = px.bar(genero_score.head(15).to_pandas(), x='Genres', y='Nota M√©dia', title='Top 15 G√™neros com Melhores Notas')
    graficos['grafico_nota_genero_top'] = fig2.to_html(full_html=False, include_plotlyjs='cdn')

    fig3 = px.bar(genero_score.tail(15).to_pandas(), x='Genres', y='Nota M√©dia', title='15 G√™neros com Piores Notas')
    graficos['grafico_nota_genero_worst'] = fig3.to_html(full_html=False, include_plotlyjs='cdn')

    fig4 = px.bar(combo_freq.head(15).to_pandas(), x='Genres_combination', y='Frequencia',
                  title='üîó Combina√ß√µes de G√™neros Mais Comuns (com 2 ou mais g√™neros)')
    graficos['grafico_combos'] = fig4.to_html(full_html=False, include_plotlyjs='cdn')

    fig5 = px.bar(studio_avg.head(15).to_pandas(), x='Studios', y='Nota M√©dia',
                  title='üé¨ Est√∫dios com Melhores Notas M√©dias')
    graficos['grafico_estudios'] = fig5.to_html(full_html=False, include_plotlyjs='cdn')

    fig6 = px.scatter(relacao_popularidade, x='Score', y='Members', color='Genres_combination',
                      size='Members', hover_data=['Genres_combination'],
                      title='Rela√ß√£o entre Nota e Popularidade por G√™nero')
    graficos['grafico_pop'] = fig6.to_html(full_html=False, include_plotlyjs='cdn')

    return graficos