# -*- coding: utf-8 -*-
"""anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwJb1_8QjbIvOSElGqKC8x-H_iecRHnA

# An√°lise de Dados em S√©ries de Anime:  G√™neros, Avalia√ß√µes e Tend√™ncias

### Equipe:
* Maria J√∫lia Silva Fonseca Guedes Nobre
* Vin√≠cius Jos√© Arag√£o de Almeida Barrozo

### Objetivos:
- Identificar os g√™neros mais frequentes.
- Avaliar quais g√™neros t√™m as melhores (e piores) notas m√©dias.
- Descobrir as combina√ß√µes de g√™neros mais comuns.
- Analisar a rela√ß√£o entre popularidade e avalia√ß√£o.
- Testar um modelo preditivo baseado nas avalia√ß√µes.

# 1. Inicializa√ß√£o da Database

Download dos arquivos via API do kaggle e cria√ß√£o do dataframe inicial
"""

import polars as pl
import numpy as np

# Baixar e carregar o dataset
anime_polars = pl.read_csv("databases/anime.csv", null_values="Unknown")


"""# 2. Pr√© Processamento

###  2.1. Remover valores nulos em colunas importantes (`Genres` e `Scores`)
"""

df_clean = anime_polars.filter(
    (anime_polars['Genres'].is_not_null()) & (anime_polars['Score'].is_not_null())
)

"""### 2.2. Separar a coluna `Genres` em uma lista"""

df_clean = df_clean.with_columns(
    pl.col('Genres')
    .str.replace("Hentai", "Adult Content")
    .str.split(", ")  # converte para lista
)

"""###  2.3. Criar coluna com combina√ß√£o ordenada dos g√™neros"""


def process_genres(genres):
    try:
        if genres is not None and len(genres) > 0:
            return ", ".join(sorted(genres))
        else:
            return ""
    except (TypeError, AttributeError):
        return ""


df_clean = df_clean.with_columns(
    pl.col('Genres').map_elements(process_genres, return_dtype=pl.Utf8).alias('Genres_combination')
)

"""# 3. An√°lises Explorat√≥rias"""

import plotly.express as px

# Explodir para an√°lise individual de g√™neros
df_exploded = df_clean.explode('Genres')

"""### 3.1. G√™neros mais frequentes

"""

genero_freq = (
    df_exploded.group_by('Genres')
    .len()
    .sort('len', descending=True)
    .rename({'len': 'Frequencia'})
)

px.bar(genero_freq.to_pandas(), x='Genres', y='Frequencia', title='G√™neros Mais Frequentes')

"""### 3.2. Nota m√©dia por g√™nero"""

genero_score = (
    df_exploded.group_by('Genres')
    .agg(pl.col('Score').mean().alias('Nota M√©dia'))
    .sort('Nota M√©dia', descending=True)
)

px.bar(genero_score.head(15).to_pandas(), x='Genres', y='Nota M√©dia', title='Top 15 G√™neros com Melhores Notas')
px.bar(genero_score.tail(15).to_pandas(), x='Genres', y='Nota M√©dia', title='15 G√™neros com Piores Notas')

"""### 3.3. Combina√ß√µes de g√™neros mais comuns"""

df_combos = df_clean.filter(pl.col('Genres').list.len() > 1)

combo_freq = (
    df_combos
    .group_by('Genres_combination')
    .agg(pl.count().alias('Frequencia'))
    .sort('Frequencia', descending=True)
)

px.bar(combo_freq.head(15).to_pandas(), x='Genres_combination', y='Frequencia',
       title='üîó Combina√ß√µes de G√™neros Mais Comuns (com 2 ou mais g√™neros)')

"""### 3.4. Est√∫dios com melhor nota m√©dia

"""

df_studios = df_clean.filter(
    (pl.col('Studios').is_not_null()) & (pl.col('Studios') != "None")
)

# Agrupar por est√∫dio e calcular m√©dia e contagem
studio_avg = (
    df_studios
    .group_by('Studios')
    .agg([
        pl.col('Score').mean().alias('Nota M√©dia'),
        pl.count().alias('Quantidade de Animes')
    ])
    .filter(pl.col('Quantidade de Animes') >= 5)
    .sort('Nota M√©dia', descending=True)
)

fig = px.bar(
    studio_avg.head(15).to_pandas(),  # Top 15 est√∫dios com melhor nota m√©dia
    x='Studios',
    y='Nota M√©dia',
    title='üé¨ Est√∫dios com as Melhores Notas M√©dias (com pelo menos 5 animes)',
    text='Nota M√©dia',
    labels={'Studios': 'Est√∫dio', 'Nota M√©dia': 'Nota M√©dia'}
)
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(xaxis_tickangle=-45)

""" ### 3.5. Rela√ß√£o entre popularidade e avalia√ß√£o"""

relacao_popularidade = df_clean.select(['Score', 'Members', 'Genres_combination']).to_pandas()

px.scatter(relacao_popularidade, x='Score', y='Members', color='Genres_combination',
           size='Members', hover_data=['Genres_combination'],
           title='Rela√ß√£o entre Nota e Popularidade por G√™nero')

"""# 4. Modelo SVM para predi√ß√£o de notas

### 4.1. Filtragem das colunas necess√°rias
"""

df_para_ml = df_clean.select(
    ['MAL_ID', 'Name', 'Genres', 'Score']
)

df_para_ml_com_membros = df_clean.select(
    ['MAL_ID', 'Name', 'Genres', 'Score', 'Members']
)

"""### 4.2. One-Hot Encoding nos generos das listas de cada linha

Uso de Machine Learning utilizando a database a fim de validar as transforma√ß√µes realizadas e uso da mesma
"""


def one_hot_encode(df, column_name):
    # Get all unique genres
    all_genres = df[column_name].explode().unique().sort()

    expressions = []
    for genre in all_genres:
        expressions.append(
            pl.col(column_name).list.contains(genre).alias(f"{column_name}_{genre}")
        )

    df = df.with_columns(expressions)
    return df.drop(column_name)


df_para_ml = one_hot_encode(df_para_ml, 'Genres')
df_para_encontrar = df_para_ml.drop('Name')
df_para_ml = df_para_ml.drop('Name', 'MAL_ID')

df_para_ml_com_membros = one_hot_encode(df_para_ml_com_membros, 'Genres')
df_para_ml_com_membros = df_para_ml_com_membros.drop('Name', 'MAL_ID')


"""### 4.3. Fun√ß√£o de treinamento e teste

Implementa√ß√£o de modelo de KNN utilizando 10-10-fold para predi√ß√£o da nota baseado em generos, contendo ou n√£o o numero de membros de cada entrada.
"""

from sklearn.model_selection import KFold
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
from numpy import mean


def train_and_evaluate_knn(df, n_neighbors=5):
        X = df.drop('Score').to_numpy()
        y = df['Score'].to_numpy()
        n_folds = 10
        kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)
        mse_scores = []
        last_model = None

        for train_index, test_index in kf.split(X):
            X_train, X_test = X[train_index], X[test_index]
            y_train, y_test = y[train_index], y[test_index]
            model = KNeighborsRegressor(n_neighbors=n_neighbors)
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse = mean_squared_error(y_test, y_pred)
            mse_scores.append(mse)
            last_model = model  # Salva o √∫ltimo modelo treinado

        average_mse = mean(mse_scores)
        return average_mse, mse_scores, last_model



_, _, modelo = train_and_evaluate_knn(df_para_ml)

def predict_score_knn(generos_booleans, model=modelo, df_treino=df_para_ml):
        """
        model: modelo KNeighborsRegressor j√° treinado
        generos_booleans: list[bool], presen√ßa dos g√™neros na ordem de generos_lista
        df_treino: DataFrame usado no treino (para pegar nomes das colunas)
        """
        # Monta o vetor de entrada (g√™neros + membros)
        X_input = np.array([*generos_booleans]).reshape(1, -1)
        # Identifica colunas True
        colunas_true = [col for col, val in zip(df_treino.drop('Score').columns, generos_booleans) if val]
        print("Colunas com valor True:", colunas_true)
        # Faz a predi√ß√£o
        predicted_score = model.predict(X_input)[0]
        return predicted_score

# =====================
# Fun√ß√µes utilit√°rias para recomenda√ß√£o de animes
# =====================

def get_top_animes_by_genres(generos_booleans, n=10, df_treino=df_para_encontrar):
    """
    Retorna os n animes com maior Score que possuem todos os g√™neros marcados como True em generos_booleans.
    Prioriza combina√ß√µes exatas, depois inclui os que t√™m g√™neros extras.
    """
    generos_cols = df_treino.drop('Score','MAL_ID').columns
    generos_array = np.array(df_treino[generos_cols]) == True
    generos_booleans = np.array(generos_booleans, dtype=bool)

    # M√°scara para combina√ß√£o exata
    mask_exata = np.all(generos_array == generos_booleans, axis=1)
    # M√°scara para conter todos os g√™neros selecionados (mas pode ter extras)
    mask_contem = np.all(generos_array[:, generos_booleans] == True, axis=1)

    # Filtra e ordena
    df_exato = df_treino.filter(mask_exata).sort('Score', descending=True)
    df_extra = df_treino.filter(mask_contem & ~mask_exata).sort('Score', descending=True)

    # Junta e retorna apenas os MAL_IDs
    top_animes = pl.concat([df_exato, df_extra]).head(n)
    return top_animes.select(['MAL_ID'])


def get_anime_info_by_mal_ids(mal_ids, df_treino):
    """
    Retorna informa√ß√µes dos animes na ordem dos MAL_IDs fornecidos.
    """
    if not mal_ids:
        return pl.DataFrame({'Name': [], 'Score': [], 'Genres_combination': []})
    # Cria DataFrame de ordena√ß√£o
    ordem_df = pl.DataFrame({'MAL_ID': mal_ids, 'order_idx': list(range(len(mal_ids)))})
    # Filtra e faz join para manter a ordem
    df_filtrado = df_treino.filter(pl.col('MAL_ID').is_in(mal_ids))
    df_ordenado = ordem_df.join(df_filtrado, on='MAL_ID', how='left').sort('order_idx')
    return df_ordenado.select(['Name', 'Score', 'Genres_combination'])

# =====================
# Exemplo de uso (para integra√ß√£o com interface)
# =====================
# generos_booleans = [True, False, ...]  # conforme a ordem dos g√™neros do seu dataset
# top_ids = get_top_animes_by_genres(generos_booleans, n=10, df_treino=df_para_encontrar)
# info = get_anime_info_by_mal_ids(top_ids['MAL_ID'].to_list(), df_treino=df_clean)
# print(info)
# =====================


# fun√ß√£o que baseado numa lista de generos, retorna 5 animes com a maior nota que possuam estes generos
def get_top_animes(generos_booleans, n=10):
    """
    generos_booleans: list[bool], presen√ßa dos g√™neros na ordem de generos_lista
    n: n√∫mero de animes a serem retornados
    Retorna: DataFrame polars com coluna 'MAL_ID' dos animes selecionados
    """
    return get_top_animes_by_genres(generos_booleans, n=n)

# Fun√ß√£o para obter informa√ß√µes detalhadas dos animes a partir de um DataFrame polars de MAL_IDs
def get_anime_info(mal_id_df, df_treino=df_clean):
    """
    mal_id_df: DataFrame polars com coluna 'MAL_ID' (resultado de get_top_animes)
    df_treino: DataFrame polars com informa√ß√µes completas dos animes
    Retorna: DataFrame polars com colunas ['Name', 'Score', 'Genres_combination']
    """
    if mal_id_df.is_empty():
        return pl.DataFrame({'Name': [], 'Score': [], 'Genres_combination': []})
    mal_ids = mal_id_df['MAL_ID'].to_list()
    df_filtrado = df_treino.filter(pl.col('MAL_ID').is_in(mal_ids))
    df_info = df_filtrado.select(['Name', 'Score', 'Genres_combination'])
    return df_info

if __name__ == "__main__":
    """### 4.4. Resultados do modelo
    
    4.4.1. Modelo somente com Score e generos
    """

    average_mse, mse_scores, _ = train_and_evaluate_knn(df_para_ml)
    print("MSE por fold:", mse_scores)
    print("M√©dia do erro quadr√°tico m√©dio:", average_mse)

    """4.4.2. Modelo com n√∫mero de membros"""

    average_mse_membros, mse_scores_membros, _ = train_and_evaluate_knn(df_para_ml_com_membros)
    print(f"MSE por fold: {mse_scores_membros}")
    print(f"M√©dia do erro quadr√°tico m√©dio: {average_mse_membros}")

def gerar_graficos_dashboard():
    graficos = {}

    # G√™neros mais frequentes
    fig1 = px.bar(genero_freq.to_pandas(), x='Genres', y='Frequencia', title='üé≠ G√™neros Mais Frequentes')
    graficos['grafico_generos_freq'] = fig1.to_html(full_html=False, include_plotlyjs='cdn')

    # Top 15 G√™neros com Melhores Notas (linha)
    fig2 = px.line(
        genero_score.head(15).to_pandas(),
        x='Genres',
        y='Nota M√©dia',
        markers=True,
        title='üìà Top 15 G√™neros com Melhores Notas'
    )
    fig2.update_traces(mode='lines+markers+text', texttemplate='%{y:.2f}', textposition='top center')
    graficos['grafico_nota_genero_top'] = fig2.to_html(full_html=False, include_plotlyjs='cdn')

    # 15 G√™neros com Piores Notas (linha)
    fig3 = px.line(
        genero_score.tail(15).to_pandas(),
        x='Genres',
        y='Nota M√©dia',
        markers=True,
        title='üìâ 15 G√™neros com Piores Notas'
    )
    fig3.update_traces(mode='lines+markers+text', texttemplate='%{y:.2f}', textposition='top center')
    graficos['grafico_nota_genero_worst'] = fig3.to_html(full_html=False, include_plotlyjs='cdn')

    # Combina√ß√µes de g√™neros mais comuns
    fig4 = px.bar(combo_freq.head(15).to_pandas(), x='Genres_combination', y='Frequencia',
                  title='üîó Combina√ß√µes de G√™neros Mais Comuns (com 2 ou mais g√™neros)')
    graficos['grafico_combos'] = fig4.to_html(full_html=False, include_plotlyjs='cdn')

    # Est√∫dios com nomes simples (sem v√≠rgula)
    studio_avg_simples = studio_avg.filter(~pl.col('Studios').str.contains(","))
    fig5 = px.bar(
        studio_avg_simples.head(15).to_pandas().sort_values(by='Nota M√©dia'),
        x='Nota M√©dia',
        y='Studios',
        orientation='h',
        title='üèÜ Est√∫dios com Melhores Notas M√©dias (nome √∫nico)',
        text='Nota M√©dia'
    )
    fig5.update_traces(texttemplate='%{text:.2f}', textposition='outside')
    graficos['grafico_estudios'] = fig5.to_html(full_html=False, include_plotlyjs='cdn')

    # Popularidade x Nota com bolhas
    relacao_popularidade_nome = df_clean.select(['Score', 'Members', 'Name']).to_pandas()

    fig6 = px.scatter(
        relacao_popularidade_nome,
        x='Score',
        y='Members',
        color='Score',  # voc√™ pode usar 'Score' para colorir por intensidade
        size='Members',
        hover_name='Name',
        title='üìä Popularidade vs Nota por Anime (Gr√°fico de Bolhas)'
    )
    graficos['grafico_pop'] = fig6.to_html(full_html=False, include_plotlyjs='cdn')

    # Score distribution
    df_scores_distrib = df_clean.with_columns(
    pl.col('Score').round(0).alias('ScoreArredondado')
    )

    score_dist = (
        df_scores_distrib
        .group_by('ScoreArredondado')
        .agg(pl.col('Members').sum().alias('TotalMembros'))
        .sort('ScoreArredondado', descending=True)
    )

    fig7 = px.line(
        score_dist.to_pandas(),
        x='ScoreArredondado',
        y='TotalMembros',
        markers=True,
        title='üìà Distribui√ß√£o de Usu√°rios por Nota (Score)'
    )
    fig7.update_traces(mode='lines+markers+text', texttemplate='%{y}', textposition='top center')
    graficos['grafico_score_dist'] = fig7.to_html(full_html=False, include_plotlyjs='cdn')

    # Pizza chart - Distribui√ß√£o de G√™neros
    fig8 = px.pie(
        genero_freq.to_pandas().head(10),
        values='Frequencia',
        names='Genres',
        title='üçï Distribui√ß√£o de G√™neros (Top 10)'
    )
    graficos['grafico_pizza_generos'] = fig8.to_html(full_html=False, include_plotlyjs='cdn')

    return graficos

